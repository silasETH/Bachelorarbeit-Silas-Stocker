{
    "task_description_collection": {
        "Match": "Implementieren Sie die Methode Match.matchNumber(long A, int M). Die Methode soll für eine Zahl A und eine nicht-negative drei-stellige Zahl M die Position von M in A zurückgeben. Sei M eine Zahl mit den Ziffern M2M1M0 (das heisst, es gilt M = M0 + 10 · M1 + 100 · M2), wobei jede Ziffer 0 sein kann. Zusätzlich sei A eine Zahl, sodass Ai die i-te Ziffer von A ist (das heisst, es gilt |A| = ∑i 10i · Ai), wobei A unendlich viele führende Nullen hat. Die Position von M in A ist die kleinste Zahl j, sodass Aj = M0 und Aj+1 = M1 und Aj+2 = M2 gilt. Die Methode soll -1 zurückgeben, falls es kein solches j gibt. Beispiele: matchNumber(32857890, 789) soll 1 zurückgeben. matchNumber(37897890, 789) soll 1 zurückgeben. matchNumber(1800765, 7) soll 2 zurückgeben. matchNumber(1800765, 8) soll -1 zurückgeben (die drei Ziffern von 8 sind 008). matchNumber(75, 7) soll 1 zurückgeben (da 007 and Position 1 von 0075 ist). Implementieren Sie die Berechnung in der Methode int matchNumber(long A, int M), welche sich in der Klasse Match befindet. Die Deklaration der Methode ist bereits vorgegeben. Sie können davon ausgehen, dass 0 ≤ M < 1000 gilt. In der main Methode der Klasse Match finden Sie die oberen Beispiele als kleine Tests, welche Beispiel-Aufrufe zur matchNumber-Methode machen.",
        "Pattern": "Gegeben sei eine k × k Matrix M von int-Werten, welche in Java als ein 2D-Array repräsentiert wird. Diese Matrix enthält das Muster, das Sie in einer n × n Martix O finden sollen (n ≥ k > 0). Wir sagen, dass die Matrix O die Matrix M für eine Ursprungposition (x, y) (mit 0 ≤ x < n, 0 ≤ y < n) enthält, wenn für alle i und j mit 0 ≤ i < k, 0 ≤ j < k gilt: O[x + i][y + j] = M[i][j]. Es ist möglich, dass eine Matrix O die Matrix M für verschiedene Ursprungpositionen (x1, y1), (x2, y2), ... enthält (oder für keine). Wenn es keine Ursprungposition (x, y) gibt, für die eine Matrix O die Matrix M enthält, dann kann durch maximal k^2 Korrekturschritte die Matrix O in eine Matrix O′ so verändert werden, so dass danach die Matrix O′ die Matrix M enthält. (Es müssen für eine Ursprungposition (x, y) alle die Elemente O[x + i][y + j] geändert werden, für die O[x + i][y + j] ≠ M[i][j]. Jeder Korrekturschritt setzt ein Element des Arrays.) Implementieren Sie in der Klasse Pattern die Methode match(int[][] origin, int[][] muster), welche die minimale Anzahl der Korrekturschritte und eine dazu passende Ursprungposition findet. Dabei ist muster eine k × k Matrix M von int-Werten und origin eine n × n Matrix von int-Werten. Sie können davon ausgehen, dass beide Parameter nicht null sind und dass k ≤ n. Die Methode match gibt das Ergebnis in einem Objekt record der Klasse MatchRecord zurück. Dabei muss (record.x, record.y) eine Ursprungsposition in der Matrix origin sein, für welche die Anzahl der Korrekturschritte minimal ist, damit die korrigierte Matrix origin’ die Matrix muster enthält. record.count muss dabei der minimalen Anzahl Korrekturschritte entsprechen. Wenn die Matrix origin die Matrix muster an der Position (x, y) ohne Korrekturschritte enthält, dann ist die Anzahl der Korrekturschritte 0. Wenn es mehrere Positionen A = {(x1, y1), (x2, y2), ....} gibt, so dass die Matrix origin die Matrix muster für alle Ursprungspositionen (xi, yi) ∈ A mit q Korrekturschritten enthält und q das Minimum der nötigen Korrekturschritte ist, dann können Sie die Anzahl Korrekturschritte q und eine beliebige Position (xi, yi) ∈ A zurückgeben.",
        "Bills": "In dieser Aufgabe sollen Sie einen Teil des Systems implementieren, das für den lokalen Stromversorger die Rechnungen erstellt. Vervollständigen Sie die process-Methode in der Klasse Bills. Die Methode hat zwei Argumente: einen Scanner, von dem Sie den Inhalt der Eingabedatei lesen sollen, und einen PrintStream, in welchen Sie die unten beschriebenen Informationen schreiben. Ihr Programm muss nur korrekt formatierte Eingabedateien unterstützen. Ein Beispiel einer solchen Datei finden Sie im Projekt unter dem Namen 'Data.txt'. Exceptions im Zusammenhang mit Ein- und Ausgabe können Sie ignorieren. Eine valide Eingabedatei enthält Zeilen, die entweder den Tarif, der angewendet werden soll, oder die Daten für den Stromverbrauch eines Kunden beschreiben. Der Verbrauch eines Kunden ist niemals grösser als 100000 Kilowattstunden. Eine Tarifbeschreibung hat folgendes Format: Tarif n l1 p1 . . . ln pn. Folgendes gilt für die Parameter: • Tarif (so geschrieben) ist ein Keyword, das angibt, dass die Zeile einen Tarif beschreibt. • n ist eine positive ganze Zahl, welche die Anzahl der Intervalle angibt, für welche ein Strompreis festgelegt ist. • Auf n folgt eine Folge von n Paaren von ganzen Zahlen (l1 p1 . . . ln pn). Die erste Zahl eines Paares gibt die Obergrenze des Intervalls an und die zweite den Preis für diesen Verbrauch; für ein i, so dass 1 ≤ i ≤ n, ist li also der Verbrauch (in Kilowattstunden), bis zu welchem der Strompreis pi (in Rappen pro Kilowattstunde) zur Anwendung kommt (li > 0 und pi ≥ 0). Die Paare sind jeweils mit einem Whitespace voneinander getrennt (und li und pi jeweils voneinander auch). Hier sind einige Beispiele für Tarifbeschreibungen: 1. Tarif 1 100000 30 Es gibt ein Intervall und für jede Kilowattstunde müssen 30 Rappen bezahlt werden. 2. Tarif 2 1000 10 100000 30 Es gibt zwei Intervalle. Die ersten 1000 Kilowattstunden kosten 10 Rappen pro Kilowattstunde. Der Rest kostet 30 Rappen pro Kilowattstunde. 3. Tarif 3 100 40 1000 10 100000 30 Es gibt drei Intervalle. Die ersten 100 Kilowattstunden kosten 40 Rappen pro Kilowattstunde. Die nächsten 1000 Kilowattstunden kosten 10 Rappen pro Kilowattstunde. Der Rest kostet 30 Rappen pro Kilowattstunde. Wenn ein Kunde im Jahr 2000 Kilowattstunden verbraucht, so beträgt die Rechnung für das erste Beispiel 600 Franken, im zweiten Beispiel 400 Franken und 410 Franken im dritten. Die Beschreibung des Stromverbrauchs eines Kunden hat folgendes Format: ID vq1 vq2 vq3 vq4. Hierbei gilt für die Parameter: • ID ist eine positive ganze Zahl. • vq1 ist eine ganze Zahl, die den Verbrauch im ersten Quartal in Kilowattstunden angibt (vq1 ≥ 0). • vq2 ist eine ganze Zahl, die den Verbrauch im zweiten Quartal in Kilowattstunden angibt (vq2 ≥ 0). • vq3 ist eine ganze Zahl, die den Verbrauch im dritten Quartal in Kilowattstunden angibt (vq3 ≥ 0). • vq4 ist eine ganze Zahl, die den Verbrauch im vierten Quartal in Kilowattstunden angibt (vq4 ≥ 0). Hier ist ein Beispiel für eine Verbrauchsbeschreibung: 115 0 0 0 2000. Der Kunde mit ID 115 hat nur im vierten Quartal Strom verbraucht. Da waren es 2000 Kilowattstunden. Ein einmal gelesener Tarif wird für alle Kunden angewendet, die nach dieser Tarifinformation in der Eingabedatei erscheinen. Wenn ein neuer Tarif erscheint, dann gilt der danach für die weiteren Kunden bis auf Weiteres. Sie können davon ausgehen, dass eine Kunden-ID nur einmal in der Eingabedatei vorkommen kann und dass die erste Zeile der Eingabedatei eine Tarifbeschreibung ist. Die Methode process soll die Eingabedatei verarbeiten und für jeden Kunden eine Zeile 'ID b' in den der Methode in output übergebenen PrintStream schreiben. ID ist die ID des Kunden (int) und b ist eine ganze Zahl, die die jeweilige Rechnung für den Jahresverbrauch in Franken angibt. (Zuerst muss der Jahresverbrauch berechnet werden, dann kann der entsprechende Tarif angewendet werden.) Berechnen Sie den Rechnungsbetrag und runden Sie das Resultat anschließend (vor der Ausgabe, aber nach den Berechnungen) auf die nächste ganze Zahl. Sie können hierfür die Methode Math.round(double a) verwenden. Die Ausgabe darf keine weiteren Zeichen enthalten. Sie können den Betrag so ausgeben, wie er von der println-Anweisung herausgegeben wird, d.h. Sie brauchen das Ergebnis nicht zu formatieren. Tipp: Sie können die Aufgabe ohne weitere Vorgaben implementieren. Wir empfehlen, dass Sie sich überlegen, was sinnvolle Klassen sein könnten und was für Teilaufgaben (die dann als Methode implementiert werden können) zweckmäßig sind.",
        "Triangle": "Die Klasse Triangle erlaubt die Darstellung von Z × S Dreiecksmatrizen (von int Werten). Z und S sind immer strikt größer als 1 (d.h., > 1). Eine Z × S Dreiecksmatrix hat Z Zeilen X0, X1, ..., XZ−1, wobei Zeile Xi genau (i * (S − 1)/(Z − 1)) + 1 viele Elemente hat. Dieser Ausdruck wird nach den Regeln für int Ausdrücke in Java ausgewertet. Für eine Dreiecksmatrix D ist Di,j das (j + 1)-te Element in der (i + 1)-ten Zeile. D0,0 ist das erste Element in der ersten Zeile [die immer genau 1 Element hat]. Beachten Sie, dass es möglich ist, dass zwei (aufeinanderfolgende) Zeilen dieselbe Anzahl Elemente haben. In der Datei Triangle.java finden Sie die Klasse Triangle mit einem Konstruktor Triangle(int z, int s), der eine z × s Dreiecksmatrix erstellt. Dieser Konstruktor setzt die Werte aller Elemente auf 0. Vervollständigen Sie diese Klasse, so dass die folgenden Methoden unterstützt werden: 1. int get(int i, int j) gibt das Element Di,j zurück. 2. void put(int i, int j, int value) setzt das Element Di,j auf den Wert value. 3. int[] linear() liefert die Elemente in der kanonischen Reihenfolge (die Elemente jeder Zeile mit steigendem Index, und die Zeilen in steigender Reihenfolge). 4. void init(int[] data) ersetzt die Elemente von D durch die Werte in data. Sie dürfen annehmen, dass data genauso viele Elemente hat wie D. Die Methode setzt die Elemente von D, so dass die Folge D.init(data); int[] y = D.linear(); in einen Array y resultiert für den Arrays.equals(y, data) den Wert true ergibt. 5. void add(Triangle t) Ein Aufruf D.add(t) addiert zu jedem Element Di,j den Wert von ti,j, falls ti,j existiert. Falls ti,j nicht existiert, dann bleibt Di,j unverändert. Tests finden Sie in der Datei “TriangleTest.java”. Die Datei “TriangleGradingTest.java” enthält die Tests, welche wir bei der Prüfung für die Korrektur verwendet haben. Wir empfehlen, diese Tests erst zu verwenden, wenn Sie denken, dass Ihre Lösung korrekt ist, damit Sie sehen können, wie Sie bei einer Prüfung abgeschnitten hätten.",
        "Graphs": "In dieser Aufgabe implementieren Sie ein Program, das bestimmte Graphen generiert. Die Klasse Node representiert einen Knoten eines Graphen. Die Methode Node.getNeighbors() gibt alle Nachbarn eines Knotens zurück. Ein Knoten B ist ein Nachbar von A, falls es im Graphen eine gerichtete Kante von A zu B gibt. Ein Hyperwürfel mit n-Dimensionen ist ein Graph mit 2n Knoten. Um den Graphen zu erklären, weisen wir jedem Knoten ein einzigartiges Label zu. Als Label verwenden wir Sequenzen aus 0, 1 der Länge n, e.g. für n = 3 mit 8 Knoten sind die Labels 000, 001, 010, 011, 100, 101, 110, 111. Für ein Label x ist xi das i-te Element der Sequenz (beginnend bei 0). Ein Knoten A mit Label x hat eine Kante zu einem Knoten B mit Label y genau dann wenn, die Labels x und y sich nur an einer Stelle unterscheiden. Das heisst, Σi<n i=0 |xi − yi| = 1 gilt. Implementieren Sie die Methode Graphs.cube(int n). Die Methode gibt einen Knoten zurück von einem Hyperwürfel mit n Dimensionen. Sie dürfen annehmen, dass n nicht negativ ist. Die Methode darf einen beliebigen Knoten des Hyperwürfels zurückgeben. Tipp: Vielleicht implementieren Sie die Methode rekursiv.",
        "SquareGrid": "In dieser Aufgabe betrachten wir gerichtete Graphen, wobei es für jeden Knoten g höchstens zwei gerichtete Kanten von g zu anderen Knoten f , h geben kann (f , g, h können gleich sein). Wir unterscheiden dabei zwischen der rechten und der unteren Kante (und damit dem rechten und dem unteren Knoten). Die Klasse Node repräsentiert einen Knoten in einem solchen Graphen. Die Methode Node.getRight() (bzw. Node.getDown()) gibt den rechten Knoten (bzw. unteren Knoten) zurück (als Node-Objekt). Wenn der rechte Knoten von n0 nicht existiert, dann gibt Node.getRight() null zurück (analog für den unteren Knoten). Die Methode Node.setRight(Node r) (bzw. Node.setDown(Node d)) setzt den rechten (bzw. unteren) Knoten. Das Ziel der Aufgabe ist, einen von einem Node-Objekt definierten Graphen zu analysieren. Konkret geht es darum, die Grösse des grössten quadratischen Gitters in dem Graphen zu bestimmen, der mit dem übergebenen Node-Objekt beschrieben wird, welches den gleichen Ursprungsknoten wie der Graph hat. Ein Teilgraph G von einem Graphen G′ (wie oben definiert) mit Ursprungsknoten u definiert ein quadratisches Gitter mit Ursprungsknoten u und Koordinaten K (wobei K ⊆ N≥0 × N≥0; das heisst, Koordinaten haben keine negativen Komponenten), so dass folgende Bedingungen gelten: • Jeder Knoten in G ist auch in G′ und jede Kante in G ist auch in G′. • Jeder Knoten in G ist über die gerichteten Kanten vom Ursprungsknoten u erreichbar. • Es gibt gleich viele Knoten in G wie Koordinaten in K. Ausserdem wird jede Koordinate (i, j) ∈ K durch genau einen einzigartigen Knoten n(i,j) in G repräsentiert. Das heisst, wenn {(i, j), (i′, j′)} ⊆ K und (i, j)̸ = (i′, j′), dann gilt n(i,j)̸ = n(i′,j′ ). • Sei (i, j) ∈ K. Wenn der untere Knoten von n(i,j) existiert, dann gilt (i + 1, j) ∈ K und der untere Knoten von n(i,j) ist gegeben durch n(i+1,j). Wenn der rechte Knoten von n(i,j) existiert, dann gilt (i, j + 1) ∈ K und der rechte Knoten von n(i,j) ist gegeben durch n(i,j+1). • Sei n die Grösse des Quadrats (n ≥ 1). Dann ist K gegeben durch K = {(i, j) | 0 ≤ i < n, 0 ≤ j < n}. Implementieren Sie die Methode SquareGrid.analyzeSquareGrid(Node origin), welche die Grösse des grössten quadratischen Gitters in dem Graphen mit Ursprungsknoten origin (welches origin als Ursprungsknoten hat) zurückgibt. Sie können davon ausgehen, dass origin nicht null ist (das bedeutet im Umkehrschluss, dass das kleinste Quadrat immer Grösse 1 hat). In Abbildung 1 hat für den Ursprungsknoten n(0,0) das grösste Quadrat Grösse 2. In Abbil- dung 2a hat für den Ursprungsknoten n(0,0) das grösste Quadrat Grösse 1, und in Abbildung 2b hat für den Ursprungsknoten n(0,0) das grösste Quadrat ebenfalls Grösse 2 (das grösste Quadrat für den Ursprungsknoten n(0,1) hat hier ebenfalls Grösse 2; für alle anderen Urpsrungsknoten in dem Graphen hat das grösste Quadrat Grösse 1). In der Klasse Main finden Sie eine main-Methode, welche Sie verwenden können, um Ihre Implementierung zu testen. In der Datei “SquareGridTest.java” finden Sie ausserdem einige Tests.",
        "Database": "In dieser Aufgabe implementieren Sie für eine Datenbank von Personengesundheitsdaten das Deklassifizieren von Einträgen (Task a) und das Verlinken von Einträgen (Task b). Alle Unteraufgaben können separat gelöst werden. Die Datenbank selber ist bereits mit der Klasse Database implementiert. Die Datenbank hält eine Liste von Einträgen, welche durch die Klasse Item repräsentiert werden. Die folgenden 4 Paragraphen erklären alle in der Vorlage gegebenen Klassen im Detail. Item Die Klasse Item repräsentiert einen Datenbankeintrag mit 4 Attributen: eine ID (int), ein Alter (int), einen Gesundheitswert (int), und ein Sicherheitslevel, welches durch die Klasse Level repräsentiert wird. Alter und Gesundheitswert sind immer ≥ 0. Die Methoden Item.getID(), Item.getAge(), Item.getHealth(), Item.getLevel() geben jeweils die ID, das Alter, den Gesundheitswert, und das Sicherheitslevel eines Eintrags zurück. Die Methode Item.setHealth(int newHealth) setzt den Gesundheitswert auf newHealth. Die anderen Attribute können nicht geändert werden. Level Die Klasse Level repräsentiert ein Sicherheitslevel. Ein Sicherheitslevel wird über eine Liste von Integern definiert, welches in einem Attribut der Klasse Level gespeichert wird und von der Methode Level.getPoints() zurückgegeben wird. Ein Level A ist verwandt mit einem Level B, falls die Summe der Werte in A.getPoints() gleich der Summe der Werte in B.getPoints() ist. Zum Beispiel ist das Level [1, 2, 3, 4] verwandt mit den Levels [10] und [4, 6] (die Summe ist überall 10), aber nicht mit dem Level [4, 5]. ItemFactory Die Klasse ItemFactory wird verwendet, um Datenbankeinträge zu erstellen. Die Methode ItemFactory.createItem(Level level, int id, int age, int health) gibt ein Exemplar der Klasse Item zurück, deren Attribute mit den Argumenten initialisiert wurden. Database Die Klasse Database repräsentiert eine Datenbank und hat folgende vorgegebene Methoden: • Database.getItemFactory() gibt ein Exemplar von ItemFactory zurück. Die ItemFactory I ist assoziiert mit der Datenbank D, falls I von D.getItemFactory() zurückgegeben wird. • Database.add(Item item) fügt der Datenbank den Eintrag item hinzu. • Database.getItems() gibt die Liste aller Einträge zurück, welcher der Datenbank hinzugefügt wurden. Sie dürfen annehmen, dass für eine Datenbank D alle Einträge in D.getItems() eine einzigartige ID haben, über D.add hinzugefügt wurden, über D.getItemFactory() erstellt wurden, und keiner anderen Datenbank hinzugefügt werden. Ein hinzugefügter Eintrag wird nie wieder entfernt. a) Implementieren Sie die Methode ItemFactory.createDeclass(Level level, int id, int targetId), die einen Deklassifikationseintrag zurückgibt. Ein Deklassifikationseintrag ist selber ein Eintrag, also ein Exemplar der Klasse Item. Ein Deklassifikationseintrag hat damit auch eine ID, ein Sicherheitslevel, ein Alter, und einen Gesundheitswert, welche von den entsprechenden getter-Methoden zurückgegeben werden. ID und Sicherheitslevel eines Deklassifikationseintrags sind jeweils das id und level Argument des createDeclass Aufrufs, mit welchem der Eintrag erstellt wurde. Das Alter und der Gesundheitswert eines Deklassifikationseintrags sind jeweils das Alter und der Gesundheitswert des Zieleintrags vom Deklassifikationseintrag. Der Zieleintrag von einem Deklassifikationseintrag D ist der Eintrag E, so dass • E.getID() gleich dem Parameter targetId ist, mit welchem D erstellt wurde; und • E aus der Datenbank ist, mit welcher die ItemFactory assoziiert ist, mit welcher D erstellt wurde. Falls es keinen Zieleintrag gibt, wird eine IllegalArgumentException von der Methode createDeclass geworfen. Beachten Sie, dass Zieleinträge selber Deklassifikationseinträge sein können. Ein Aufruf der Methode Item.setHealth(h) auf einem Deklassifikationseintrag hat keinen Effekt; dies wird nicht in den Tests überprüft. Ein Deklassifikationseintrag R erreicht einen Eintrag A, falls entweder A der Zieleintrag von R ist oder falls der Zieleintrag von R ein Deklassifikationseintrag ist, welcher A erreicht. Die Methode createDeclass wirft eine IllegalArgumentException, falls der zurückzugebene Deklassifikationseintrag R einen Eintrag erreicht, dessen Level verwandt ist mit dem Level von R. Zur Erinnerung: Der Paragraph über die Klasse Level erklärt, wann zwei Level verwandt sind. b) Implementieren Sie die Methode Database.createLink(List<Integer> ids). Der Methodenaufruf D.createLink(ids) verlinkt alle Einträge der Datenbank D miteinander, welche eine ID haben, die im Argument ids enthalten ist. Wenn E.setHealth(h) auf einem Eintrag E aufgerufen wird, dann wird der Gesundheitswert aller Einträge, welche mit E verlinkt sind, auf das Argument h gesetzt. Einträge können beliebig oft verlinkt werden und verlinken ist transitiv, das heisst, wenn ein Eintrag A mit einem Eintrag B verlinkt ist und B mit einem Eintrag C verlinkt ist, dann ist A auch mit C verlinkt. Verlinken ist auch immer symmetrisch, das heisst, wenn A mit B verlinkt ist, dann ist auch B mit A verlinkt. Zusätzlich ist verlinken reflexiv, das heisst, ein Eintrag ist immer mit sich selber verlinkt. Der Aufruf D.createLink(ids) soll eine IllegalArgumentException werfen, falls es eine ID im Argument ids gibt, für welche es keinen Eintrag mit der gleichen ID in der Datenbank D gibt.",
        "ContactTracer": "In dieser Aufgabe implementieren Sie eine Contact-Tracing-Applikation, welche es ermöglichen soll, Kontakte während eines Virus-Ausbruches nachzuverfolgen. Ihre Implementierung soll zunächst Begegnungen zwischen verschiedenen Person-Instanzen anonym protokollieren, so dass bei einem positivem Test die Benachrichtigung aller Personen möglich ist, die direkt oder indirekt mit einer positiv getesteten Person in Kontakt standen. Anonyme Begegnungen. Um Anonymität zu gewährleisten, dürfen zwei Personen A und B bei einer Begegnung lediglich anonyme Integer-IDs austauschen, ohne dabei die Identität der jeweils anderen Person aufzudecken. Beide Personen speichern hierbei sowohl die eigene ID als auch die ID der anderen Person. Bei der positiven Testung von A kann dann mithilfe der anonymen IDs, die A genutzt hat, festgestellt werden, ob B einer dieser IDs begegnet ist. Um zu vermeiden, dass wiederkehrende IDs die Identifikation einer Person über mehrere Begegnungen hinweg ermöglichen, benutzt jede Person für jede Begegnung frische IDs, welche über eine zentrale Klasse ContactTracer vergeben werden. Frisch bedeutet hierbei, dass eine ID zuvor noch nie bei einer Begegnung verwendet wurde. Direkte und indirekte Kontakte. Nachdem eine Reihe an Begegnungen protokolliert wurden, wird eine oder mehrere Personen positiv getestet. Mit dem erfassten Netzwerk aus Begegnungen soll Ihre Applikation dann zwei verschiedene Arten an Kontaktpersonen bestimmten: • Als direkte Kontakte gelten alle Personen, die eine Begegnung mit einer positiv getesteten Person hatten. • Als indirekte Kontakte hingegen gelten alle Personen, die zwar selbst keine Begegnung mit einer positiv getesteten Person hatten, jedoch Kontakt mit mindestens einer anderen Person, welche als direkter Kontakt gilt, hatten. Indirekte Kontakte mit mehr als einer Zwischenperson müssen Sie dabei nicht berücksichtigen. Sie dürfen dabei annehmen, dass zunächst alle Begegnungen erfasst werden und erst dann Personen positiv getestet werden. Nach der ersten positiven Testung finden keine weiteren Begegnungen mehr statt. Benachrichtigungen. Da nicht alle Personen gleichermassen gefährdet sind, soll Ihre Applikation die Benachrichtigung der Kontaktpersonen vom Alter, der Art des Kontaktes, sowie dem Testergebnis der jeweiligen Kontaktperson abhängig machen. Dabei soll eine der drei Warnstufen Keine Benachrichtigung, Low-Risk-Benachrichtigung oder High-Risk-Benachrichtigung ausgesprochen werden. Zu Beginn haben alle Personen die Standard-Warnstufe Keine Benachrichtigung und gelten als negativ getestet. Davon ausgehend sollen nach jedem registrierten positiven Test die zugehörigen Kontaktpersonen wie folgt benachrichtigen werden: Testergebnis der Kontaktperson Alter der Kontaktperson Direkter Kontakt Indirekter Kontakt Positiv - Keine Benachr. Keine Benachr. Negativ ≤ 60 Jahre alt High-Risk Keine Benachr. Negativ > 60 Jahre alt High-Risk Low-Risk Eine negativ getestete Person, die höchstens 60 Jahre alt ist und die nur in indirektem Kontakt zu einer positiven Person stand, soll beispielsweise keine Benachrichtigung erhalten (Reihe 2). Eine negativ getestete Person über 60 Jahre hingegen soll als indirekter Kontakt eine Low-Risk-Benachrichtigung erhalten (Reihe 3). Wenn mehrere Personen positiv getestet werden, soll Ihre Applikation immer die höchste geltende Warnstufe für die anderen, negativ getesteten Personen berechnen. Dabei ist die Ordnung der Warnstufen wie folgt definiert: Keine Benachrichtigung < Low-Risk Benachrichtigung < High-Risk Benachrichtigung. Positiv getestete Personen hingegen sollen immer die Warnstufe Keine Benachrichtigung erhalten. Im Allgemeinen dürfen Sie zudem annehmen, dass eine Person, die einmal positiv getestet wurde, für den Rest der Laufzeit Ihrer Applikation als positiv getestet gilt. Implementierung. Erweiteren Sie den vorgegebenen Code für die Klasse ContactTracer und das Interface Person wie folgt, um die Contact-Tracing-Applikation umzusetzen: Implementieren Sie das Interface Person mit den folgenden public Methoden: • Person.getUsedIds(). Diese Methode gibt die Liste aller IDs zurück (List<Integer>), die für diese Person als frische ID verwendet wurden, um eine Begegnung zu protokollieren. Nach Hinzufügen einer ID in diese Liste muss dieselbe ID in die jeweilige Person.getSeenIds()-Liste des Gegenübers eingetragen sein. • Person.getSeenIds(). Diese Methode gibt die Liste aller IDs zurück (List<Integer>), die diese Person als die frische ID des jeweiligen Gegenübers bei einer Begegnung protokolliert hat. Nach Hinzufügen einer ID in diese Liste muss dieselbe ID in die jeweilige Person.getUsedIds()-Liste des Gegenübers eingetragen sein. • Person.getNotification(). Diese Methode gibt den aktuellen Benachrichtigungsstatus der Person zurück. Der Rückgabewert soll vom Enum-Typ NotificationType sein, welcher vorgegeben ist und die drei möglichen Warnstufen modelliert. NotificationType ist im Interface Person definiert und enthält die drei Werte NoNotification (keine Benachrichtigung), LowRiskNotification (Low-Risk-Benachrichtigung) und HighRiskNotification (High-Risk-Benachrichtigung). • Person.setTestsPositively(). Diese Methode wird aufgerufen, um eine Person als positiv getestet zu markieren. Nach dem Aufrufen dieser Methode sollen automatisch alle Kontakte von A benachrichtigt worden sein und die entsprechenden Warnstufe per Person.getNotification() zurückgeben. Implementieren Sie zusätzlich die Klasse ContactTracer, welche die folgenden public Methoden besitzt: • ContactTracer.registerEncounter(Person p1, Person p2). Mit dieser Methode wird eine (beidseitige) Begegnung zwischen Person-Objekten p1 und p2 protokolliert, indem die beiden Personen anonyme IDs austauschen. Die ausgetauschten IDs müssen dabei unterschiedlich sein. Eine Begegnung zwischen p1 und p2 ist beidseitig und muss somit auch als Begegnung zwischen p2 und p1 gewertet werden. • ContactTracer.createPerson(int age). Diese Methode gibt ein Person-Objekt zurück. Das Alter der Person ist durch den age Parameter bestimmt. Alle Person-Objekte werden von der Methode ContactTracer.createPerson(int age) erstellt. Der ContactTracer wird über den parameterfreien Konstruktor ContactTracer() instanziiert. Sie dürfen annehmen, dass nie mehr als 1024 Begegnungen zwischen Personen protokolliert werden. Implementieren Sie auf Basis dieser Vorlage eine Lösung für das Contact-Tracing-Problem. Tests finden Sie in der Datei “ContactTracerTest.java”. Die Datei “ContactTracerGradingTest.java” enthält die Tests, welche wir bei der Prüfung für die Korrektur verwendet haben. Wir empfehlen, diese Tests erst zu verwenden, wenn Sie denken, dass Ihre Lösung korrekt ist, damit Sie sehen können, wie Sie bei einer Prüfung abgeschnitten hätten."    
    },
    "template_collection": {
        "Match": "public class Match {\n\tpublic static void main(String[] args) {\n\t\ttestMatchNumber(1, 32857890, 789);\n\t\ttestMatchNumber(1, 37897890, 789);\n\t\ttestMatchNumber(2, 1800765, 7);\n\t\ttestMatchNumber(-1, 1800765, 8);\n\t\ttestMatchNumber(1, 75, 7);\n\t}\n\tpublic static void testMatchNumber(int expected, long A, int M) {\n\t\tint result = matchNumber(A, M);\n\t\tif (expected == result) {\n\t\t\tSystem.out.println('Passed');\n\t\t} else {\n\t\t\tSystem.out.println(\"Failed. Expected \" + expected + \", but got \" + result + \".\");\n\t\t}\n\t}\n\tpublic static int matchNumber(long A, int M) {\n\t\t// TODO\n\t\treturn -1;\n\t}\n}",
        "Pattern": "class MatchRecord {\n\tint x;\n\tint y;\n\tint count;\n\tpublic MatchRecord(int xPos, int yPos, int count) {\n\t\tx = xPos;\n\t\ty = yPos;\n\t\tthis.count = count;\n\t}\n}\n\npublic class Pattern {\n\tpublic static MatchRecord match(int[][] origin, int[][] muster) {\n\t\t//TODO\n\t\treturn null;\n\t}\n\tpublic static void main(String[] args) {\n\t\t// Sie koennen die main Methode beliebig aendern.\n\t\tint[][] origin = { \n\t\t\t\t{ 1, 2, 1, 3, 1},\n\t\t\t\t{ 3, 1, 2, 1, 2},\n\t\t\t\t{ 1, 3, 1, 3, 1},\n\t\t\t\t{ 3, 1, 3, 1, 3},\n\t\t\t\t{ 1, 3, 1, 3, 1}\n\t\t};\n\t\tint[][] muster = { \n\t\t\t{2, 1},\n\t\t\t{1, 2}\n\t\t};\n\t\tMatchRecord r;\n\t\tr = Pattern.match(origin, muster);\n\t\tSystem.out.println(\"Ursprungsposition: (\" + r.x + \",\" + r.y + \")\");\n\t\tSystem.out.println(\"Anzahl Korrekturschritte: \" + r.count);\n\t}\n}",
        "Bills": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Bills {\n\n  public static void main(String[] args) throws FileNotFoundException {\n    String inputFile = \"Data.txt\";\n    Scanner input = new Scanner(new File(inputFile));\n    PrintStream output = new PrintStream(System.out);\n\n    process(input, output);\n\n    input.close();\n  }\n\n  /**\n   * \u00c4ndern Sie nicht die Signatur der Methode\n   */\n  public static void process(Scanner input, PrintStream output) {\n    // TODO Lesen Sie das File von input und geben Sie Ihre L\u00f6sung nach output aus.\n  }\n}",
        "Triangle": "import java.util.Arrays;\n\npublic class Triangle {\n\t\n\tint rowMax;\n\tint colMax;\n\tint[][] rows;\n\t\n\tpublic Triangle(int z, int s) {\n\t\tif (z <= 1 || s <= 1) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t} else {\n\t\t\trowMax = z;\n\t\t\tcolMax = s;\n\t\t}\n\t\trows = new int[rowMax][];\n\t\t\n\t\tint j = 1;\n        for (int i=0; i<rowMax; i++) {\n         j = (i*(colMax-1)/(rowMax-1)) + 1;\n         rows[i] = new int[j];\n        }\n\t}\n\t\n\tpublic int get(int i, int j) {\n\t\t// TODO\n\t\treturn -1;\n\t}\n\t\n\tpublic void put(int i, int j, int value) {\n\t\t// TODO\n\t}\n\t\n\tpublic void init(int[] data) {\n\t    // TODO\n\t}\n\t\n\tpublic int[] linear() {\n\t\t// TODO\n\t\treturn null;\n\t}\n\t\n\tpublic void add(Triangle t){\n\t\t// TODO\n\t}\n\t\n\tpublic String toString() {\n\t\t   String tmp = \"\";\n\t\t   for (int i = 0; i<rowMax; i++) {\n\t\t\t   tmp = tmp + Arrays.toString(rows[i]) + \" \\n\";\n\t\t   }\n\t\t   return tmp;\n\t   }\n}\n",
        "Graphs": "public class Graphs {\n\n\tpublic static Node cube(int n) {\n\t\t// TODO\n\t\treturn null;\n\t}\n\t\n\t// Eine Hilfsmethod zum printen von Graphen.\n\t// Ueberschreiben Sie Node.toString() um einen schoeneren Output zu bekommen.\n\tpublic static void printGraph(Node node) {\n\t\tLinkedNodeList visited = new LinkedNodeList();\n\t\tprintGraphRecursive(node, visited);\n\t}\n\t\n\tpublic static void printGraphRecursive(Node node, LinkedNodeList visited) {\n\t\tvisited.addFirst(node);\n\t\t\n\t\tNode[] nexts = node.getNeighbors();\n\t\t\n\t\tString[] names = new String[nexts.length];\n\t\tfor (int i = 0; i < nexts.length; i += 1) { \n\t\t\tnames[i] = nexts[i].toString();\n\t\t}\n\t\t\n\t\tSystem.out.println(node + \" -> \" + String.join(\",\", names));\n\t\t\n\t\tfor (Node next : node.getNeighbors()) {\n\t\t\tif (!visited.contains(next)) {\n\t\t\t\tprintGraphRecursive(next, visited);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A singly-linked list of {@link Node}s with fast {@link #addFirst(Node)} and\n * {@link #addLast(Node)} methods.\n */\n\nclass LinkedNodeList {\n    \n\tNodeLink first;\n\tNodeLink last;\n\tint size;\n\t\n\tNode get(int index) {\n\t\t\treturn getNode(index).value;\n\t}\n\t\n\tvoid set(int index, Node value) {\n\t\t\tgetNode(index).value = value;\n\t}\n\t\n\tboolean isEmpty() {\n\t\t\treturn size == 0;\n\t}\n\t\n\tvoid addFirst(Node value) {\n\t\t\tNodeLink newNode = new NodeLink(value);\n\t\t\tnewNode.next = first;\n\t\t\tfirst = newNode;\n\t\t\tif(last == null) {\n\t\t\t\tlast = newNode;\n\t\t\t}\n\t\t\t\n\t\t\tsize++;\n\t}\n\t\n\tvoid addLast(Node value) {\n\t\t\tNodeLink newNode = new NodeLink(value);\n\t\t\tif(isEmpty()) {\n\t\t\t\tfirst = newNode;\n\t\t\t} else {\n\t\t\t\tlast.next = newNode;\n\t\t\t}                    \n\t\t\t\n\t\t\tlast = newNode;\n\t\t\tsize++;\n\t}\n\t\n\tNode removeFirst() {\n\t\t\tif(isEmpty()) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\t\n\t\t\tNode value = first.value;\n\t\t\tif(first == last) {\n\t\t\t\t\t// List has only one element, so just clear it\n\t\t\t\t\tclear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\tfirst = first.next;\n\t\t\t\t\tsize--;\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t}\n\t\n\tNode removeLast() {\n\t\t\tif(isEmpty()) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\t\n\t\t\tNode value = last.value;\n\t\t\tif(first == last) {\n\t\t\t\t\t// List has only one element, so just clear it\n\t\t\t\t\tclear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\t// List has more than one element\n\t\t\t\t\tNodeLink currentNode = first;\n\t\t\t\t\twhile(currentNode.next != last) {\n\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t}    \n\t\t\t\t\t\n\t\t\t\t\tcurrentNode.next = null;\n\t\t\t\t\tlast = currentNode;\n\t\t\t\t\tsize--;\n\t\t\t}\n\t\t\treturn value;\n\t}\n\t\n\tNode remove(int index) {\n\t\tif (index == 0) {\n\t\t\treturn removeFirst();\n\t\t} else if (index == size-1) {\n\t\t\treturn removeLast();\n\t\t} else {\n\t\t\tNodeLink node = getNode(index-1);\n\t\t\tNode removed = node.next.value;\n\t\t\tnode.next = node.next.next;\n\t\t\tsize -= 1;\n\t\t\treturn removed;\n\t\t}\n\t}\n\t\n\tboolean contains(Node room) {\n\t\tfor(NodeLink n = first; n != null; n = n.next) {\n\t\t\tif (n.value == room) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid clear() {\n\t\t\tfirst = last = null;\n\t\t\tsize = 0;\n\t}\n\t\n\tNode[] toArray() {\n\t\t\tNode[] array = new Node[size];\n\t\t\tint i = 0;\n\t\t\tfor(NodeLink n = first; n != null; n = n.next, i++) {\n\t\t\t\tarray[i] = n.value;\n\t\t\t}\n\t\t\treturn array;\n\t}\n\t\n\t/**\n\t * For internal use only.\n\t */\n\tNodeLink getNode(int index) {\n\t\t\tif(index >= size)\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\n\t\t\tNodeLink current = first;\n\t\t\tfor(int i = 0; i < index; i++) {\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\treturn current;\n\t}\n\t\n\tstatic LinkedNodeList of(Node... Nodes) {\n\t\tLinkedNodeList result = new LinkedNodeList();\n\t\tfor (int i = 0; i < Nodes.length; i += 1) {\n\t\t\tresult.addLast(Nodes[i]);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tNode node0 = Graphs.cube(2);\n\t\tGraphs.printGraph(node0);\n\t}\n\n}\n\n\nclass Node {\n\t\n\tNode[] getNeighbors() {\n\t\t// TODO \n\t\treturn null;\n\t}\n}\n\n\n/**\n * A node of a singly-linked list of Node values\n */\n\nclass NodeLink {\n\n\tNode value;\n    NodeLink next;\n    \n    NodeLink(Node value) {\n        this.value = value;\n    }\n}",
        "SquareGrid": "class Main {\n\n    public static void main(String[] args) {\n        // Sie koennen die main-Methode beliebig aendern.\n        Node n00 = new Node();\n        Node n10 = new Node();\n        Node n01 = new Node();\n\n        n00.setDown(n10);\n        n00.setRight(n01);\n\n        System.out.println(\"analyzeSquareGrid Resultat (erwartet: 1) \" + SquareGrid.analyzeSquareGrid(n00));\n\n        Node n11 = new Node();\n        n01.setDown(n11);\n        n10.setRight(new Node());\n\n        System.out.println(\"analyzeSquareGrid Resultat (erwartet: 1): \" + SquareGrid.analyzeSquareGrid(n00));\n\n        n10.setRight(n11);\n\n        System.out.println(\"analyzeSquareGrid Resultat (erwartet: 2): \" + SquareGrid.analyzeSquareGrid(n00));\n    }\n}\n\nclass Node {\n\n\t/***\n\t*   Sie koennen weitere Attribute (und auch Methoden) hinzufuegen, wenn Sie wollen\n\t***/\n\n\tprivate Node down;\n\tprivate Node right;\n\t\n\tpublic void setRight(Node n) {\n\t\tthis.right = n;\n\t}\n\t\n\tpublic Node getRight() {\n\t\treturn this.right;\n\t}\n\t\n\tpublic void setDown(Node n) {\n\t\tthis.down = n;\n\t}\n\t\n\tpublic Node getDown() {\n\t\treturn this.down;\n\t}\n}\n\npublic class SquareGrid {\n\n    public static int analyzeSquareGrid(Node origin) {\n        // TODO\n        return -1;\n    }\n}",
        "Database": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Database {\n\n\tprivate List<Item> items = new ArrayList<>();\n\tprivate ItemFactory factory = new ItemFactory(); \n\n\tpublic void add(Item item) { \n\t\titems.add(item); \n\t}\n\n\tpublic List<Item> getItems() { \n\t\treturn new ArrayList<>(items);\n\t}\n\n\tpublic ItemFactory getItemFactory() { \n\t\treturn factory; \n\t}\n\t\n\tpublic void createLink(List<Integer> ids) {\n\t\t// TODO\n\t}\n}\n\n\nclass Item {\n\t\n\tprivate Level level;\n\tprivate int id;\n\tprivate int age;\n\tprivate int health;\n\n\tpublic Item(Level level, int id, int age, int health) {\n\t\tthis.level = level;\n\t\tthis.id = id;\n\t\tthis.age = age;\n\t\tthis.health = health;\n\t}\n\n\tpublic Level getLevel() { return level; }\n\tpublic int getID() { return id; }\n\tpublic int getAge() { return age; }\n\tpublic int getHealth() { return health; }\n\n\tpublic void setHealth(int newHealth) { health = newHealth; }\n}\n\n\nclass ItemFactory {\n\n\tpublic Item createItem(Level level, int id, int age, int health) { \n\t\treturn new Item(level, id, age, health); \n\t}\n\n\tpublic Item createDeclass(Level level, int id, int targetId) {\n\t\t// TODO\n\t\treturn null;\n\t}\n}\n\nclass Level {\n\t\n\tprivate List<Integer> points;\n\t\n\tpublic Level(List<Integer> points) {\n\t\tthis.points = new ArrayList<>(points);\n\t}\n\t\n\tpublic List<Integer> getPoints() {\n\t\treturn new ArrayList<>(points);\n\t}\n}",
        "ContactTracer": "import java.util.List;\nimport java.lang.Integer;\n\npublic class ContactTracer {\n    /**\n     * Erstellt eine neue Person im Kontext dieses Contact Tracers.\n     *\n     * Alle Person-Objekte, die von dieser Methode erstellt werden, sollen\n     * sich gegenseitig begegnen und benachrichtigen können.\n     */\n    public Person createPerson(int age) {\n        // TODO\n        return null;\n    }\n\n    /**\n     * Protokolliert eine (beidseitige) Begegnung von p1 und p2.\n     */\n    public void registerEncounter(Person p1, Person p2) {\n        // TODO\n    }\n}\n\nclass Main {\n\n    public static void main(String[] args) {\n        // Sie koennen die main-Methode beliebig aendern.\n\n        ContactTracer tracer = new ContactTracer();\n\n        Person alice = tracer.createPerson(20);\n        Person bob = tracer.createPerson(30);\n        Person margret = tracer.createPerson(30);\n\n        tracer.registerEncounter(alice, bob);\n\n        // Alice wird positiv getestet\n        alice.setTestsPositively();\n\n        // Alice ist positiv, hat daher keine Benachrichtigung\n        System.out.println(\"Alice notification (erwartet: NoNotification): \" + alice.getNotification());\n        // Bob ist ein direkter Kontakt -> High-Risk Benachrichtigung\n        System.out.println(\"Bob notification (erwartet: HighRiskNotification): \" + bob.getNotification());\n\n        System.out.println(\"Margret notification (erwartet: NoNotification): \" + margret.getNotification());\n    }\n}\n\ninterface Person {\n    /** Die verschiedenen Warnstufen */\n    public enum NotificationType {\n        NoNotification,\n        HighRiskNotification,\n        LowRiskNotification\n    }\n\n    /**\n     *  Diese Methode gibt die Liste aller IDs zurück, die für diese Person als\n     *  frische ID verwendet wurden, um eine Begegnung zu protokollieren. Nach Hinzufügen\n     *  einer ID in diese Liste, muss dieselbe ID in die jeweilige Person.getSeenIds()-Liste\n     *  des Gegenübers eingetragen sein.\n     */\n    public List<Integer> getUsedIds();\n\n    /**\n     * Diese Methode gibt die Liste aller IDs zurück, die\n     * diese Person als die frische ID des jeweiligen Gegenübers bei einer Begegnung\n     * protokolliert hat. Nach Hinzufügen einer ID in diese Liste muss dieselbe ID in\n     * die jeweilige Person.getUsedIds()-Liste des Gegenübers eingetragen sein.\n     */\n    public List<Integer> getSeenIds();\n\n    /** Gibt die aktuelle Art von Benachrichtigung dieser Person zurück. */\n    public NotificationType getNotification();\n\n    /** Markiert diese Person als positiv getestet und benachrichtigt alle relevanten Kontakte. */\n    public void setTestsPositively();\n}"
    }
}